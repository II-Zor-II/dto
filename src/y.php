<?php
class TestArrayObject extends ArrayObject {
    protected $data = [
        'firstname' => '',
        'lastname' => '',
        'mother' => [
            'firstname' => '',
            'lastname' => '',
        ],
    ];
    public function __construct($input = null, $flags = 0, $iterator_class = "ArrayIterator")
    {


        $class = get_class($this);
        $array = ($input) ? $input : $this->data;
        foreach ($array as $key => $value) {
            if (is_array($value)) {
                //$template = (isset($this->template[$key])) ? $this->template[$key] : [];
                //$this->offsetSet($key, new $class($value, $flags, $iterator_class, $template));
                $this->offsetSet($key, new $class($value, $flags, $iterator_class));
            }
            else {
                $this->offsetSet($key, $value);
            }

        }
        print "--------------CONSTRUCTOR COMPLETE----------\n";
        $this->setFlags($flags);
    }
//
//    public function __toString()
//    {
//        return json_encode($this->toArray(), JSON_PRETTY_PRINT);
//    }

    // Only get used if ARRAY_AS_PROPS is NOT set
    // This does get called if STD_PROP_LIST is set
    // but then the value doesn't stick
    // Accessed when the object is written to via object notation
    public function __set($name, $val) {
        printf("%s(%s)\n", __FUNCTION__, implode(", ", func_get_args()));
        $this[$name] = $val;
    }

    /**
     * Get the filtered key or false on fail
     * @param $key string dotted key
     * @param $enforce_root_level boolean if true, the key must be valid as a root level key (e.g. '.x' or 'y')
     * @return mixed : boolean false on invalid key, filtered key on success
     */
    protected function getNormalizedKey($key, $enforce_root_level = false)
    {
        if (!is_scalar($key)) {
            return false;
        }
        if ($key == '.') {
            return '.';
        }
        $key = trim($key, '.');
        if (strpos($key, '..') != false) {
            return false;
        }

        if (!preg_match('/^[\.a-z\-_\x7f-\xff]{1}[\.a-z0-9\-_\x7f-\xff]*$/i', $key)) {
            return false;
        }

        // No dots allowed for root-level keys!
        if ($enforce_root_level) {
            if (strpos($key, '.') != false) {
                return false;
            }
            return $key;
        }

        return ($key) ? $key : '.';
    }

    public function __get($name) {
        printf("%s(%s)\n", __FUNCTION__, implode(", ", func_get_args()));
        return $this[$name];
    }


    /**
     * Get the internal data, return the location indicated by $dotted_key.  When writing to the location, this
     * should be called using the reference syntax:
     *
     *      $abc = &$this->get('a.b.c');
     *      $abc = 'new value';
     *      print_r($this->toArray()); // will properly show the updated value
     *
     * See http://php.net/manual/en/language.references.return.php
     *
     * @param $raw_dotted_key string
     * @return array (returned by reference)
     * @throws \InvalidArgumentException
     */
    public function &get($raw_dotted_key)
    {
        if (!$dotted_key = $this->getNormalizedKey($raw_dotted_key)) {
            //$this->log('Cannot get data due to invalid key: ' . print_r($raw_dotted_key, true), 'error');
            throw new \InvalidArgumentException('Cannot get data due to invalid key: ' . print_r($raw_dotted_key, true));
        }
        if ($dotted_key == '.') {
            return $this->data;
        }
        $keyPath = explode('.', trim($dotted_key, '.'));

        $location =& $this;
print ';;;;;;;;;'.$location;exit;
        // Traverse (by reference) down to the specified path,
        // return false if we try to traverse into paths that don't exist.
        foreach ($keyPath as $k) {
            if (!is_array($location) || !array_key_exists($k, $location)) {
                //$this->log('Invalid location "' . $dotted_key . '" in ' . get_called_class() . '::$data', 'error');
                throw new \InvalidArgumentException('Invalid location "' . $dotted_key . '" in ' . get_called_class() . '::$data');
            }
            $location =& $location[$k]; // traverse down!
        }

        return $location;
    }

    public function offsetGet($index)
    {
        printf("%s(%s)\n", __FUNCTION__, implode(", ", func_get_args()));
        return parent::offsetGet($index); // TODO: Change the autogenerated stub
    }

    // Accessed when the object is written to via array notation
    public function offsetSet($index, $newval)
    {

        printf("%s(%s)\n", __FUNCTION__, $index.','.(string) '----');
        return parent::offsetSet($index, $newval); // TODO: Change the autogenerated stub
    }

    public function toArray(TestArrayObject $obj = null)
    {
        $obj = ($obj) ? $obj : $this;
        foreach ($obj as $k => $v) {
            if ($v instanceof TestArrayObject) {
                $output[$k] = $this->toArray($v);
            }
            else {
                $output[$k] = $v;
            }
        }

        return $output;
    }

    /**
     * {@inheritdoc}
     */
    public function toJson($pretty = false)
    {
        if ($pretty) {
            return json_encode($this->toArray(), JSON_PRETTY_PRINT);
        }
        return json_encode($this->toArray());
    }

    /**
     * {@inheritdoc}
     */
    public function toObject($dotted_key = '.')
    {
        return json_decode($this->toJson($dotted_key));
    }


}

//$obj = new TestArrayObject(['firstname' => 'bob', 'mother'=>['firstname'=>'Deb']]);
print "--------------START-----------------------\n";
$obj = new TestArrayObject();

$obj->firstname = 'Nicole';           // works
$obj->mother->firstname = 'Debbie';   // works

//$obj['firstname'] = 'Me';               // works
//$obj['mother']['firstname'] = 'Mimi';   // works


// Warning: Attempt to assign property of non-object
//$obj->mother->firstname = 'Sally';
//$obj->mother['firstname'] = 'Sally'; // does not take
//print_r((array) $obj->mother);
//print_r((array) $obj); // <-- working, but always buries data inside storage:ArrayObject:private

//print_r($obj->toArray());         // works
//print_r($obj->mother->toArray());   // works

//$obj->does_not_exist = 'barbar';

//print_r($obj->toArray());         // works

//print_r($obj->toObject());

//print $obj->get('mother.firstname');